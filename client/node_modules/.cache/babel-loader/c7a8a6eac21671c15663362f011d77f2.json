{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Lions/FullstackFinalProject/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Lions/FullstackFinalProject/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Lions/FullstackFinalProject/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\n\nvar PostgrestQueryBuilder = /*#__PURE__*/function () {\n  function PostgrestQueryBuilder(url, _ref) {\n    var _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        schema = _ref.schema,\n        fetch = _ref.fetch;\n\n    _classCallCheck(this, PostgrestQueryBuilder);\n\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\r\n   * Perform a SELECT query on the table or view.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   *\r\n   * @param options.count - Count algorithm to use to count rows in the table or view.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n\n\n  _createClass(PostgrestQueryBuilder, [{\n    key: \"select\",\n    value: function select(columns) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$head = _ref2.head,\n          head = _ref2$head === void 0 ? false : _ref2$head,\n          count = _ref2.count;\n\n      var method = head ? 'HEAD' : 'GET'; // Remove whitespaces except when quoted\n\n      var quoted = false;\n      var cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n\n      if (count) {\n        this.headers['Prefer'] = \"count=\".concat(count);\n      }\n\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\r\n     * Perform an INSERT into the table or view.\r\n     *\r\n     * By default, inserted rows are not returned. To return it, chain the call\r\n     * with `.select()`.\r\n     *\r\n     * @param values - The values to insert. Pass an object to insert a single row\r\n     * or an array to insert multiple rows.\r\n     *\r\n     * @param options - Named parameters\r\n     *\r\n     * @param options.count - Count algorithm to use to count inserted rows.\r\n     *\r\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n     * hood.\r\n     *\r\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n     * statistics under the hood.\r\n     *\r\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n     * numbers.\r\n     *\r\n     * @param options.defaultToNull - Make missing fields default to `null`.\r\n     * Otherwise, use the default value for the column. Only applies for bulk\r\n     * inserts.\r\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(values) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          count = _ref3.count,\n          _ref3$defaultToNull = _ref3.defaultToNull,\n          defaultToNull = _ref3$defaultToNull === void 0 ? true : _ref3$defaultToNull;\n\n      var method = 'POST';\n      var prefersHeaders = [];\n\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      if (!defaultToNull) {\n        prefersHeaders.push('missing=default');\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n\n      if (Array.isArray(values)) {\n        var columns = values.reduce(function (acc, x) {\n          return acc.concat(Object.keys(x));\n        }, []);\n\n        if (columns.length > 0) {\n          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {\n            return \"\\\"\".concat(column, \"\\\"\");\n          });\n\n          this.url.searchParams.set('columns', uniqueColumns.join(','));\n        }\n      }\n\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\r\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\r\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\r\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\r\n     * exist, or if it does exist, perform an alternative action depending on\r\n     * `ignoreDuplicates`.\r\n     *\r\n     * By default, upserted rows are not returned. To return it, chain the call\r\n     * with `.select()`.\r\n     *\r\n     * @param values - The values to upsert with. Pass an object to upsert a\r\n     * single row or an array to upsert multiple rows.\r\n     *\r\n     * @param options - Named parameters\r\n     *\r\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\r\n     * duplicate rows are determined. Two rows are duplicates if all the\r\n     * `onConflict` columns are equal.\r\n     *\r\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\r\n     * `false`, duplicate rows are merged with existing rows.\r\n     *\r\n     * @param options.count - Count algorithm to use to count upserted rows.\r\n     *\r\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n     * hood.\r\n     *\r\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n     * statistics under the hood.\r\n     *\r\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n     * numbers.\r\n     *\r\n     * @param options.defaultToNull - Make missing fields default to `null`.\r\n     * Otherwise, use the default value for the column. This only applies when\r\n     * inserting new rows, not when merging with existing rows under\r\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\r\n     */\n\n  }, {\n    key: \"upsert\",\n    value: function upsert(values) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onConflict = _ref4.onConflict,\n          _ref4$ignoreDuplicate = _ref4.ignoreDuplicates,\n          ignoreDuplicates = _ref4$ignoreDuplicate === void 0 ? false : _ref4$ignoreDuplicate,\n          count = _ref4.count,\n          _ref4$defaultToNull = _ref4.defaultToNull,\n          defaultToNull = _ref4$defaultToNull === void 0 ? true : _ref4$defaultToNull;\n\n      var method = 'POST';\n      var prefersHeaders = [\"resolution=\".concat(ignoreDuplicates ? 'ignore' : 'merge', \"-duplicates\")];\n      if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      if (!defaultToNull) {\n        prefersHeaders.push('missing=default');\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n\n      if (Array.isArray(values)) {\n        var columns = values.reduce(function (acc, x) {\n          return acc.concat(Object.keys(x));\n        }, []);\n\n        if (columns.length > 0) {\n          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {\n            return \"\\\"\".concat(column, \"\\\"\");\n          });\n\n          this.url.searchParams.set('columns', uniqueColumns.join(','));\n        }\n      }\n\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\r\n     * Perform an UPDATE on the table or view.\r\n     *\r\n     * By default, updated rows are not returned. To return it, chain the call\r\n     * with `.select()` after filters.\r\n     *\r\n     * @param values - The values to update with\r\n     *\r\n     * @param options - Named parameters\r\n     *\r\n     * @param options.count - Count algorithm to use to count updated rows.\r\n     *\r\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n     * hood.\r\n     *\r\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n     * statistics under the hood.\r\n     *\r\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n     * numbers.\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(values) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          count = _ref5.count;\n\n      var method = 'PATCH';\n      var prefersHeaders = [];\n\n      if (this.headers['Prefer']) {\n        prefersHeaders.push(this.headers['Prefer']);\n      }\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        body: values,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n    /**\r\n     * Perform a DELETE on the table or view.\r\n     *\r\n     * By default, deleted rows are not returned. To return it, chain the call\r\n     * with `.select()` after filters.\r\n     *\r\n     * @param options - Named parameters\r\n     *\r\n     * @param options.count - Count algorithm to use to count deleted rows.\r\n     *\r\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n     * hood.\r\n     *\r\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n     * statistics under the hood.\r\n     *\r\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n     * numbers.\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          count = _ref6.count;\n\n      var method = 'DELETE';\n      var prefersHeaders = [];\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      if (this.headers['Prefer']) {\n        prefersHeaders.unshift(this.headers['Prefer']);\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: this.url,\n        headers: this.headers,\n        schema: this.schema,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n  }]);\n\n  return PostgrestQueryBuilder;\n}();\n\nexport { PostgrestQueryBuilder as default };","map":{"version":3,"mappings":"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","names":["PostgrestFilterBuilder","PostgrestQueryBuilder","url","headers","schema","fetch","columns","head","count","method","quoted","cleanedColumns","split","map","c","test","join","searchParams","set","allowEmpty","values","defaultToNull","prefersHeaders","push","Array","isArray","reduce","acc","x","concat","Object","keys","length","uniqueColumns","Set","column","body","onConflict","ignoreDuplicates","undefined","unshift"],"sources":["C:\\Users\\Lions\\FullstackFinalProject\\client\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestQueryBuilder.ts"],"sourcesContent":["import PostgrestBuilder from './PostgrestBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport { GetResult } from './select-query-parser'\r\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\r\n\r\nexport default class PostgrestQueryBuilder<\r\n  Schema extends GenericSchema,\r\n  Relation extends GenericTable | GenericView,\r\n  RelationName = unknown,\r\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\r\n> {\r\n  url: URL\r\n  headers: Record<string, string>\r\n  schema?: string\r\n  signal?: AbortSignal\r\n  fetch?: Fetch\r\n\r\n  constructor(\r\n    url: URL,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      schema?: string\r\n      fetch?: Fetch\r\n    }\r\n  ) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n  }\r\n\r\n  /**\r\n   * Perform a SELECT query on the table or view.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   *\r\n   * @param options.count - Count algorithm to use to count rows in the table or view.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  select<\r\n    Query extends string = '*',\r\n    ResultOne = GetResult<Schema, Relation['Row'], RelationName, Relationships, Query>\r\n  >(\r\n    columns?: Query,\r\n    {\r\n      head = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], RelationName, Relationships> {\r\n    const method = head ? 'HEAD' : 'GET'\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = (columns ?? '*')\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    if (count) {\r\n      this.headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<ResultOne[]>)\r\n  }\r\n\r\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row,\r\n    options?: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row[],\r\n    options?: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  /**\r\n   * Perform an INSERT into the table or view.\r\n   *\r\n   * By default, inserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to insert. Pass an object to insert a single row\r\n   * or an array to insert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count inserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. Only applies for bulk\r\n   * inserts.\r\n   */\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row,\r\n    options?: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row[],\r\n    options?: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    }\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\r\n  /**\r\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\r\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\r\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\r\n   * exist, or if it does exist, perform an alternative action depending on\r\n   * `ignoreDuplicates`.\r\n   *\r\n   * By default, upserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to upsert with. Pass an object to upsert a\r\n   * single row or an array to upsert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\r\n   * duplicate rows are determined. Two rows are duplicates if all the\r\n   * `onConflict` columns are equal.\r\n   *\r\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\r\n   * `false`, duplicate rows are merged with existing rows.\r\n   *\r\n   * @param options.count - Count algorithm to use to count upserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. This only applies when\r\n   * inserting new rows, not when merging with existing rows under\r\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\r\n   */\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      onConflict,\r\n      ignoreDuplicates = false,\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\r\n\r\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform an UPDATE on the table or view.\r\n   *\r\n   * By default, updated rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param values - The values to update with\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count updated rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\r\n    values: Row,\r\n    {\r\n      count,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'PATCH'\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform a DELETE on the table or view.\r\n   *\r\n   * By default, deleted rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count deleted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  delete({\r\n    count,\r\n  }: {\r\n    count?: 'exact' | 'planned' | 'estimated'\r\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\r\n    const method = 'DELETE'\r\n    const prefersHeaders = []\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}